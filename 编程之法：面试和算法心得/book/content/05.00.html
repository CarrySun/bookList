<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh-tw" xml:lang="zh-tw">
  <head>
    <title>5.0 本章导读 | 编程之法：面试和算法心得</title>
    <meta name="description" content=""/>
    <meta name="generator" content="GitBook 2.6.5"/>
    <meta name="author" content="wizardforcel"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="dir">
        
        
<div class="page">
    
        <h1 class="book-chapter" id="calibre_toc_37">5.0 本章导读</h1>
        
            <div class="section" id="section-">
            
                <h2 id="本章导读" class="calibre8">本章导读</h2>
<p class="calibre6">学习一个算法，可分为3个步骤：首先了解算法本身解决什么问题，然后学习它的解决策略，最后了解某些相似算法之间的联系。例如图算法中，</p>
<ul class="calibre10">
<li class="calibre11">广搜是一层一层往外遍历，寻找最短路径，其策略是采取队列的方法。</li>
<li class="calibre11">最小生成树是最小代价连接所有点，其策略是贪心，比如Prim的策略是贪心+权重队列。</li>
<li class="calibre11">Dijkstra是寻找单源最短路径，其策略是贪心+非负权重队列。</li>
<li class="calibre11">Floyd是多结点对的最短路径，其策略是动态规划。</li>
</ul>
<p class="calibre6">而贪心和动态规划是有联系的，贪心是“最优子结构+局部最优”，动态规划是“最优独立重叠子结构+全局最优”。一句话理解动态规划，则是枚举所有状态，然后剪枝，寻找最优状态，同时将每一次求解子问题的结果保存在一张“表格”中，以后再遇到重叠的子问题，从表格中保存的状态中查找（俗称记忆化搜索）。</p>

            
            </div>
        
    
</div>

        
        
    
    

</body></html>
