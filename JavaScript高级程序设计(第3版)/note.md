第 1 章 JavaScript 简介 

    JavaScript 是一种专为与网页交互而设计的脚本语言，由下列三个不同的部分组成：
      ECMAScript，由 ECMA-262 定义，提供核心语言功能；
      文档对象模型（DOM） ，提供访问和操作网页内容的方法和接口；
      浏览器对象模型（BOM） ，提供与浏览器交互的方法和接口。
    JavaScript 的这三个组成部分，在当前五个主要浏览器（IE、Firefox、Chrome、Safari 和 Opera）中
    都得到了不同程度的支持。其中，所有浏览器对 ECMAScript 第 3 版的支持大体上都还不错，
    而对
    ECMAScript 5 的支持程度越来越高，但对 DOM 的支持则彼此相差比较多。对已经正式纳入 HTML5 标
    准的 BOM来说，尽管各浏览器都实现了某些众所周知的共同特性，但其他特性还是会因浏览器而异。

第 2 章 在 HTML 中使用 JavaScript 

    把 JavaScript 插入到 HTML 页面中要使用 `<script>` 元素。使用这个元素可以把 JavaScript 嵌入到
    HTML页面中，让脚本与标记混合在一起；也可以包含外部的 JavaScript文件。而我们需要注意的地方有：
      在包含外部 JavaScript 文件时，必须将 src 属性设置为指向相应文件的 URL。而这个文件既可
    以是与包含它的页面位于同一个服务器上的文件，也可以是其他任何域中的文件。
      所有 `<script>` 元素都会按照它们在页面中出现的先后顺序依次被解析。在不使用 defer 和
    async 属性的情况下，只有在解析完前面 `<script>` 元素中的代码之后，才会开始解析后面
    `<script>` 元素中的代码。
      由于浏览器会先解析完不使用 defer 属性的 `<script>` 元素中的代码，然后再解析后面的内容，
    所以一般应该把 `<script>` 元素放在页面最后，即主要内容后面， `</body>` 标签前面。
      使用 defer 属性可以让脚本在文档完全呈现之后再执行。 延迟脚本总是按照指定它们的顺序执行。
      使用 async 属性可以表示当前脚本不必等待其他脚本，也不必阻塞文档呈现。不能保证异步脚
    本按照它们在页面中出现的顺序执行。
    另外，使用 `<noscript>` 元素可以指定在不支持脚本的浏览器中显示的替代内容。但在启用了脚本
    的情况下，浏览器不会显示 `<noscript>` 元素中的任何内容。

第 3 章 基本概念 

    JavaScript 的核心语言特性在 ECMA-262 中是以名为 ECMAScript 的伪语言的形式来定义的。
    ECMAScript 中包含了所有基本的语法、操作符、数据类型以及完成基本的计算任务所必需的对象，但
    没有对取得输入和产生输出的机制作出规定。理解 ECMAScript 及其纷繁复杂的各种细节，是理解其在
    Web 浏览器中的实现——JavaScript 的关键。目前大多数实现所遵循的都是 ECMA-262 第 3 版，但
    很多
    也已经着手开始实现第 5 版了。以下简要总结了 ECMAScript 中基本的要素。
      ECMASc
    ript 中的基本数据类型包括 Undefined 、 Null 、 Boolean 、 Number 和 String 。
      与其他语言不同，ECMScript 没有为整数和浮点数值分别定义不同的数据类型， Number 类型可
    用于表示所有数值。
      ECMAScript 中也有一种复杂的数据类型，即 Object 类型，该类型是这门语言中所有对象的基
    础类型。
      严格模式为这门语言中容易出错的地方施加了限制。
      ECMAScript 提供了很多与 C 及其他类 C 语言中相同的基本操作符，包括算术操作符、布尔操作
    符、关系操作符、相等操作符及赋值操作符等。
      ECMAScript 从其他语言中借鉴了很多流控制语句，例如 if 语句、 for 语句和 switch 语句等。
    ECMAScript 中的函数与其他语言中的函数有诸多不同之处。
      无须指定函数的返回值，因为任何 ECMAScript 函数都可以在任何时候返回任何值。
      实际上，未指定返回值的函数返回的是一个特殊的 undefined 值。
      ECMAScript 中也没有函数签名的概念，因为其函数参数是以一个包含零或多个值的数组的形式
    传递的。
      可以向 ECMAScript 函数传递任意数量的参数， 并且可以通过 arguments 对象来访问这些参数。
      由于不存在函数签名的特性，ECMAScript 函数不能重载。

第 4 章 变量、作用域和内存问题 

    JavaScript 变量可以用来保存两种类型的值：基本类型值和引用类型值。基本类型的值源自以下 5
    种基本数据类型： Undefined 、 Null 、 Boolean 、 Number 和 String 。基本类型值和引用类型值具
    有以下特点：
      基本类型值在内存中占据固定大小的空间，因此被保存在栈内存中；
      从一个变量向另一个变量复制基本类型的值，会创建这个值的一个副本；
      引用类型的值是对象，保存在堆内存中；
      包含引用类型值的变量实际上包含的并不是对象本身，而是一个指向该对象的指针；
      从一个变量向另一个变量复制引用类型的值，复制的其实是指针，因此两个变量最终都指向同
    一个对象；
      确定一个值是哪种基本类型可以使用 typeof 操作符，而确定一个值是哪种引用类型可以使用
    instanceof 操作符。
    所有变量（包括基本类型和引用类型）都存在于一个执行环境（也称为作用域）当中，这个执
    行环境决定了变量的生命周期，以及哪一部分代码可以访问其中的变量。以下是关于执行环境的几
    点总结：
      执行环境有全局执行环境（也称为全局环境）和函数执行环境之分；
      每次进入一个新执行环境，都会创建一个用于搜索变量和函数的作用域链；
      函数的局部环境不仅有权访问函数作用域中的变量，而且有权访问其包含（父）环境，乃至全
    局环境；
      全局环境只能访问在全局环境中定义的变量和函数，而不能直接访问局部环境中的任何数据；
      变量的执行环境有助于确定应该何时释放内存。
    JavaScript 是一门具有自动垃圾收集机制的编程语言，开发人员不必关心内存分配和回收问题。可
    以对 JavaScript 的垃圾收集例程作如下总结。
      离开作用域的值将被自动标记为可以回收，因此将在垃圾收集期间被删除。
      “标记清除”是目前主流的垃圾收集算法，这种算法的思想是给当前不使用的值加上标记，然
    后再回收其内存。
      另一种垃圾收集算法是 “引用计数” ， 这种算法的思想是跟踪记录所有值被引用的次数。 JavaScript
    引擎目前都不再使用这种算法；但在 IE 中访问非原生 JavaScript 对象（如 DOM 元素）时，这种算法仍然可能会导致问题。
      当代码中存在循环引用现象时， “引用计数”算法就会导致问题。
      解除变量的引用不仅有助于消除循环引用现象，而且对垃圾收集也有好处。为了确保有效地回
    收内存，应该及时解除不再使用的全局对象、全局对象属性以及循环引用变量的引用。

第 5 章 引用类型 

    对象在 JavaScript 中被称为引用类型的值，而且有一些内置的引用类型可以用来创建特定的对象，
    现简要总结如下：
      引用类型与传统面向对象程序设计中的类相似，但实现不同；
     Object 是一个基础类型，其他所有类型都从 Object 继承了基本的行为；
     Array 类型是一组值的有序列表，同时还提供了操作和转换这些值的功能；
     Date 类型提供了有关日期和时间的信息，包括当前日期和时间以及相关的计算功能；
     RegExp 类型是 ECMAScript 支持正则表达式的一个接口，提供了最基本的和一些高级的正则表
    达式功能。
    函数实际上是 Function 类型的实例，因此函数也是对象；而这一点正是 JavaScript 最有特色的地
    方。由于函数是对象，所以函数也拥有方法，可以用来增强其行为。
    因为有了基本包装类型，所以 JavaScript 中的基本类型值可以被当作对象来访问。三种基本包装类
    型分别是： Boolean 、 Number 和 String 。以下是它们共同的特征：
      每个包装类型都映射到同名的基本类型；
      在读取模式下访问基本类型值时，就会创建对应的基本包装类型的一个对象，从而方便了数据
    操作；
      操作基本类型值的语句一经执行完毕，就会立即销毁新创建的包装对象。
    在所有代码执行之前， 作用域中就已经存在两个内置对象： Global 和 Math 。 在大多数 ECMAScript
    实现中都不能直接访问 Global 对象；不过，Web 浏览器实现了承担该角色的 window 对象。全局变
    量和函数都是 Global 对象的属性。 Math 对象提供了很多属性和方法，用于辅助完成复杂的数学计算
    任务。

第 6 章 面向对象的程序设计 

    ECMAScript 支持面向对象（OO）编程，但不使用类或者接口。对象可以在代码执行过程中创建和
    增强，因此具有动态性而非严格定义的实体。在没有类的情况下，可以采用下列模式创建对象。
      工厂模式，使用简单的函数创建对象，为对象添加属性和方法，然后返回对象。这个模式后来
    被构造函数模式所取代。
      构造函数模式，可以创建自定义引用类型，可以像创建内置对象实例一样使用 new 操作符。不
    过，构造函数模式也有缺点，即它的每个成员都无法得到复用，包括函数。由于函数可以不局
    限于任何对象（即与对象具有松散耦合的特点） ，因此没有理由不在多个对象间共享函数。
      原型模式，使用构造函数的 prototype 属性来指定那些应该共享的属性和方法。组合使用构造
    函数模式和原型模式时，使用构造函数定义实例属性，而使用原型定义共享的属性和方法。
    JavaScript 主要通过原型链实现继承。原型链的构建是通过将一个类型的实例赋值给另一个构造函
    数的原型实现的。这样，子类型就能够访问超类型的所有属性和方法，这一点与基于类的继承很相似。
    原型链的问题是对象实例共享所有继承的属性和方法，因此不适宜单独使用。解决这个问题的技术是借
    用构造函数，即在子类型构造函数的内部调用超类型构造函数。这样就可以做到每个实例都具有自己的
    属性，同时还能保证只使用构造函数模式来定义类型。使用最多的继承模式是组合继承，这种模式使用
    原型链继承共享的属性和方法，而通过借用构造函数继承实例属性。
    此外，还存在下列可供选择的继承模式。
      原型式继承，可以在不必预先定义构造函数的情况下实现继承，其本质是执行对给定对象的浅
    复制。而复制得到的副本还可以得到进一步改造。
      寄生式继承，与原型式继承非常相似，也是基于某个对象或某些信息创建一个对象，然后增强
    对象，最后返回对象。为了解决组合继承模式由于多次调用超类型构造函数而导致的低效率问
    题，可以将这个模式与组合继承一起使用。
      寄生组合式继承，集寄生式继承和组合继承的优点与一身，是实现基于类型继承的最有效方式。

第 7 章 函数表达式 

    在 JavaScript 编程中，函数表达式是一种非常有用的技术。使用函数表达式可以无须对函数命名，
    从而实现动态编程。匿名函数，也称为拉姆达函数，是一种使用 JavaScript 函数的强大方式。以下总结
    了函数表达式的特点。
      函数表达式不同于函数声明。函数声明要求有名字，但函数表达式不需要。没有名字的函数表
    达式也叫做匿名函数。
      在无法确定如何引用函数的情况下，递归函数就会变得比较复杂；
      递归函数应该始终使用 arguments.callee 来递归地调用自身， 不要使用函数名——函数名可
    能会发生变化。
    当在函数内部定义了其他函数时，就创建了闭包。闭包有权访问包含函数内部的所有变量，原理
    如下。
      在后台执行环境中，闭包的作用域链包含着它自己的作用域、包含函数的作用域和全局作用域。
      通常，函数的作用域及其所有变量都会在函数执行结束后被销毁。
      但是，当函数返回了一个闭包时，这个函数的作用域将会一直在内存中保存到闭包不存在为止。
    使用闭包可以在 JavaScript中模仿块级作用域（JavaScript本身没有块级作用域的概念） ，要点如下。
      创建并立即调用一个函数，这样既可以执行其中的代码，又不会在内存中留下对该函数的引用。
      结果就是函数内部的所有变量都会被立即销毁——除非将某些变量赋值给了包含作用域（即外
    部作用域）中的变量。
    闭包还可以用于在对象中创建私有变量，相关概念和要点如下。
      即使 JavaScript 中没有正式的私有对象属性的概念，但可以使用闭包来实现公有方法，而通过公
    有方法可以访问在包含作用域中定义的变量。
      有权访问私有变量的公有方法叫做特权方法。
      可以使用构造函数模式、原型模式来实现自定义类型的特权方法，也可以使用模块模式、增强
    的模块模式来实现单例的特权方法。
    JavaScript 中的函数表达式和闭包都是极其有用的特性，利用它们可以实现很多功能。不过，因为
    创建闭包必须维护额外的作用域，所以过度使用它们可能会占用大量内存。

第 8 章 BOM 

    浏览器对象模型 （BOM） 以 window 对象为依托， 表示浏览器窗口以及页面可见区域。 同时， window
    对象还是 ECMAScript 中的 Global 对象，因而所有全局变量和函数都是它的属性，且所有原生的构造
    函数及其他函数也都存在于它的命名空间下。本章讨论了下列 BOM 的组成部分。
      在使用框架时，每个框架都有自己的 window 对象以及所有原生构造函数及其他函数的副本。
    每个框架都保存在 frames 集合中，可以通过位置或通过名称来访问。
      有一些窗口指针，可以用来引用其他框架，包括父框架。
     top 对象始终指向最外围的框架，也就是整个浏览器窗口。
     parent 对象表示包含当前框架的框架，而 self 对象则回指 window 。
      使用 location 对象可以通过编程方式来访问浏览器的导航系统。设置相应的属性，可以逐段
    或整体性地修改浏览器的 URL。
      调用 replace() 方法可以导航到一个新 URL，同时该 URL 会替换浏览器历史记录中当前显示
    的页面。
     navigator 对象提供了与浏览器有关的信息。到底提供哪些信息，很大程度上取决于用户的浏
    览器；不过，也有一些公共的属性（如 userAgent ）存在于所有浏览器中。
    BOM 中还有两个对象： screen 和 history ，但它们的功能有限。 screen 对象中保存着与客户端
    显示器有关的信息，这些信息一般只用于站点分析。 history 对象为访问浏览器的历史记录开了一个
    小缝隙，开发人员可以据此判断历史记录的数量，也可以在历史记录中向后或向前导航到任意页面。



第 9 章 客户端检测 

    客户端检测是 JavaScript 开发中最具争议的一个话题。由于浏览器间存在差别，通常需要根据不同
    浏览器的能力分别编写不同的代码。有不少客户端检测方法，但下列是最经常使用的。
      能力检测：在编写代码之前先检测特定浏览器的能力。例如，脚本在调用某个函数之前，可能
    要先检测该函数是否存在。这种检测方法将开发人员从考虑具体的浏览器类型和版本中解放出
    来，让他们把注意力集中到相应的能力是否存在上。能力检测无法精确地检测特定的浏览器和
    版本。
      怪癖检测：怪癖实际上是浏览器实现中存在的 bug，例如早期的 WebKit 中就存在一个怪癖，即
    它会在 for-in 循环中返回被隐藏的属性。怪癖检测通常涉及到运行一小段代码，然后确定浏
    览器是否存在某个怪癖。由于怪癖检测与能力检测相比效率更低，因此应该只在某个怪癖会干
    扰脚本运行的情况下使用。怪癖检测无法精确地检测特定的浏览器和版本。
      用户代理检测：通过检测用户代理字符串来识别浏览器。用户代理字符串中包含大量与浏览器
    有关的信息，包括浏览器、平台、操作系统及浏览器版本。用户代理字符串有过一段相当长的
    发展历史，在此期间，浏览器提供商试图通过在用户代理字符串中添加一些欺骗性信息，欺骗
    网站相信自己的浏览器是另外一种浏览器。用户代理检测需要特殊的技巧，特别是要注意 Opera
    会隐瞒其用户代理字符串的情况。即便如此，通过用户代理字符串仍然能够检测出浏览器所用
    的呈现引擎以及所在的平台，包括移动设备和游戏系统。
    在决定使用哪种客户端检测方法时，一般应优先考虑使用能力检测。怪癖检测是确定应该如何处理
    代码的第二选择。而用户代理检测则是客户端检测的最后一种方案，因为这种方法对用户代理字符串具
    有很强的依赖性。

第 10 章 DOM 

    DOM 是语言中立的 API，用于访问和操作 HTML 和 XML 文档。DOM1 级将 HTML 和 XML 文档
    形象地看作一个层次化的节点树，可以使用 JavaScript 来操作这个节点树，进而改变底层文档的外观和
    结构。
    DOM 由各种节点构成，简要总结如下。
      最基本的节点类型是 Node ，用于抽象地表示文档中一个独立的部分；所有其他类型都继承自
    Node 。
     Document 类型表示整个文档，是一组分层节点的根节点。在 JavaScript 中， document 对象是
    Document 的一个实例。使用 document 对象，有很多种方式可以查询和取得节点。
     Element 节点表示文档中的所有 HTML 或 XML 元素，可以用来操作这些元素的内容和特性。
      另外还有一些节点类型，分别表示文本内容、注释、文档类型、CDATA 区域和文档片段。
    访问 DOM 的操作在多数情况下都很直观，不过在处理 <script> 和 <style> 元素时还是存在一些
    复杂性。由于这两个元素分别包含脚本和样式信息，因此浏览器通常会将它们与其他元素区别对待。这
    些区别导致了在针对这些元素使用 innerHTML 时，以及在创建新元素时的一些问题。
    理解 DOM 的关键，就是理解 DOM 对性能的影响。DOM 操作往往是 JavaScript程序中开销最大的
    部分，而因访问 NodeList 导致的问题为最多。 NodeList 对象都是“动态的” ，这就意味着每次访问
    NodeList 对象，都会运行一次查询。有鉴于此，最好的办法就是尽量减少 DOM 操作。

第 11 章 DOM 扩展 .

    虽然 DOM 为与 XML 及 HTML 文档交互制定了一系列核心 API， 但仍然有几个规范对标准的 DOM
    进行了扩展。这些扩展中有很多原来是浏览器专有的，但后来成为了事实标准，于是其他浏览器也都提
    供了相同的实现。本章介绍的三个这方面的规范如下。
      Selectors API，定义了两个方法，让开发人员能够基于 CSS 选择符从 DOM中取得元素，这两个
    方法是 querySelector() 和 querySelectorAll() 。
      Element Traversal，为 DOM 元素定义了额外的属性，让开发人员能够更方便地从一个元素跳到
    另一个元素。之所以会出现这个扩展，是因为浏览器处理 DOM 元素间空白符的方式不一样。
      HTML5， 为标准的 DOM 定义了很多扩展功能。 其中包括在 innerHTML 属性这样的事实标准基
    础上提供的标准定义，以及为管理焦点、设置字符集、滚动页面而规定的扩展 API。
    虽然目前 DOM扩展的数量还不多，但随着 Web 技术的发展，相信一定还会涌现出更多扩展来。很
    多浏览器都在试验专有的扩展，而这些扩展一旦获得认可，就能成为“伪”标准，甚至会被收录到规范
    的更新版本中

第 12 章 DOM2 和 DOM3 

    DOM2 级规范定义了一些模块，用于增强 DOM1 级。 “DOM2 级核心”为不同的 DOM 类型引入了
    一些与 XML 命名空间有关的方法。这些变化只在使用 XML 或 XHTML 文档时才有用；对于 HTML文
    档没有实际意义。除了与 XML 命名空间有关的方法外， “DOM2 级核心”还定义了以编程方式创建
    Document 实例的方法，也支持了创建 DocumentType 对象。
    “DOM2 级样式”模块主要针对操作元素的样式信息而开发，其特性简要总结如下。
      每个元素都有一个关联的 style 对象，可以用来确定和修改行内的样式。
      要确定某个元素的计算样式 （包括应用给它的所有 CSS 规则） ， 可以使用 getComputedStyle()
    方法。
      IE不支持 getComputedStyle() 方法， 但为所有元素都提供了能够返回相同信息 currentStyle
    属性。
      可以通过 document.styleSheets 集合访问样式表。
      除 IE 之外的所有浏览器都支持针对样式表的这个接口，IE 也为几乎所有相应的 DOM功能提供
    了自己的一套属性和方法。
    “DOM2 级遍历和范围”模块提供了与 DOM结构交互的不同方式，简要总结如下。
      遍历即使用 NodeIterator 或 TreeWalker 对 DOM 执行深度优先的遍历。
     NodeIterator 是一个简单的接口，只允许以一个节点的步幅前后移动。而 TreeWalker 在提
    供相同功能的同时，还支持在 DOM 结构的各个方向上移动，包括父节点、同辈节点和子节点等
    方向。
      范围是选择 DOM结构中特定部分，然后再执行相应操作的一种手段。
      使用范围选区可以在删除文档中某些部分的同时，保持文档结构的格式良好，或者复制文档中
    的相应部分。
      IE8 及更早版本不支持“DOM2 级遍历和范围”模块，但它提供了一个专有的文本范围对象，可
    以用来完成简单的基于文本的范围操作。IE9 完全支持 DOM遍历。

第 13 章 事件 

    事件是将 JavaScript 与网页联系在一起的主要方式。 “DOM3 级事件”规范和 HTML5 定义了常见的
    大多数事件。即使有规范定义了基本事件，但很多浏览器仍然在规范之外实现了自己的专有事件，从而
    为开发人员提供更多掌握用户交互的手段。有些专有事件与特定设备关联，例如移动 Safari 中的
    orientationchange 事件就是特定关联 iOS 设备的。
    在使用事件时，需要考虑如下一些内存与性能方面的问题。
      有必要限制一个页面中事件处理程序的数量，数量太多会导致占用大量内存，而且也会让用户
    感觉页面反应不够灵敏。
      建立在事件冒泡机制之上的事件委托技术，可以有效地减少事件处理程序的数量。
      建议在浏览器卸载页面之前移除页面中的所有事件处理程序。
    可以使用 JavaScript 在浏览器中模拟事件。 “DOM2 级事件”和“DOM3 级事件”规范规定了模拟事
    件的方法，为模拟各种有定义的事件提供了方便。此外，通过组合使用一些技术，还可以在某种程度上
    模拟键盘事件。IE8及之前版本同样支持事件模拟，只不过模拟的过程有些差异。
    事件是 JavaScript中最重要的主题之一，深入理解事件的工作机制以及它们对性能的影响至关重要。

第 14 章 表单脚本 

    虽然 HTML 和 Web 应用自诞生以来已经发生了天翻地覆的变化，但 Web 表单相对却没有什么改
    变。使用 JavaScript 可以增强已有的表单字段，从而创造出新的功能，或者提升表单的易用性。为此，
    表单、表单字段都引入了相应的属性和方法，以便 JavaScript 使用。下面是本章介绍的几个概念。
      可以使用一些标准或非标准的方法选择文本框中的全部或部分文本。
      大多数浏览器都采用了 Firefox 操作选择文本的方式，但 IE 仍然坚持自己的实现。
      在文本框的内容变化时，可以通过侦听键盘事件以及检测插入的字符，来允许或禁止用户输入
    某些字符。
    除 Opera 之外的所有浏览器都支持剪贴板事件，包括 copy 、 cut 和 paste 。其他浏览器在实现剪
    贴板事件时也可以分为几种不同的情况。
      IE、Firefox、Chrome 和 Safari 允许通过 JavaScript 访问剪贴板中的数据，而 Opera 不允许这种访
    问方式。
      即使是 IE、Chrome 和 Safari，它们各自的实现方式也不相同。
      Firefox、Safari 和 Chrome 只允许在 paste 事件发生时读取剪贴板数据，而 IE 没有这个限制。
      Firefox、Safari 和 Chrome 只允许在发生剪贴板事件时访问与剪贴板相关的信息，而 IE 允许在任
    何时候访问相关信息。
    在文本框内容必须限制为某些特定字符的情况下， 就可以利用剪贴板事件来屏蔽通过粘贴向文本框
    中插入内容的操作。
    选择框也是经常要通过 JavaScript 来控制的一个表单字段。 由于有了 DOM， 对选择框的操作比以前
    要方便多了。添加选项、移除选项、将选项从一个选择框移动到另一个选择框，甚至对选项进行排序等
    操作，都可以使用标准的 DOM技术来实现。
    富文本编辑功能是通过一个包含空 HTML 文档的 iframe 元素来实现的。通过将空文档的
    designMode 属性设置为 "on" ， 就可以将该页面转换为可编辑状态， 此时其表现如同字处理软件。 另外，
    也可以将某个元素设置为 contenteditable 。 在默认情况下， 可以将字体加粗或者将文本转换为斜体，
    还可以使用剪贴板。JavaScript 通过使用 execCommand() 方法也可以实现相同的一些功能。另外，使用
    queryCommandEnabled() 、 queryCommandState() 和 queryCommandValue() 方法则可以取得有关
    文本选区的信息。由于以这种方式构建的富文本编辑器并不是一个表单字段，因此在将其内容提交给
    服务器之前，必须将 iframe 或 contenteditable 元素中的 HTML 复制到一个表单字段中。

第 15 章 使用 Canvas 绘图 

    HTML5的 <canvas> 元素提供了一组 JavaScript API， 让我们可以动态地创建图形和图像。 图形是在一
    个特定的上下文中创建的，而上下文对象目前有两种。第一种是 2D上下文，可以执行原始的绘图操作，
    比如：
      设置填充、描边颜色和模式
      绘制矩形
      绘制路径
      绘制文本
      创建渐变和模式
    第二种是 3D 上下文， 即 WebGL 上下文。 WebGL 是从 OpenGL ES 2.0 移植到浏览器中的， 而 OpenGL
    ES 2.0 是游戏开发人员在创建计算机图形图像时经常使用的一种语言。WebGL 支持比 2D 上下文更丰富
    和更强大的图形图像处理能力，比如：
      用 GLSL（OpenGL Shading Language，OpenGL 着色语言）编写的顶点和片段着色器
      支持类型化数组，即能够将数组中的数据限定为某种特定的数值类型
      创建和操作纹理
    目前，主流浏览器的较新版本大都已经支持 <canvas> 标签。同样地，这些版本的浏览器基本上也
    都支持 2D 上下文。但对于 WebGL 而言，目前还只有 Firefox 4+和 Chrome 支持它。

第 16 章 HTML5 脚本编程 

    HTML5 除了定义了新的标记规则，还定义了一些 JavaScript API。这些 API 是为了让开发人员创建
    出更好的、能够与桌面应用媲美的用户界面而设计的。本章讨论了如下 API。
      跨文档消息传递 API 能够让我们在不降低同源策略安全性的前提下，在来自不同域的文档间传
    递消息。
      原生拖放功能让我们可以方便地指定某个元素可拖动，并在操作系统要放置时做出响应。还可
    以创建自定义的可拖动元素及放置目标。
      新的媒体元素 <audio> 和 <video> 拥有自己的与音频和视频交互的 API。 并非所有浏览器支持所
    有的媒体格式，因此应该使用 canPlayType() 检查浏览器是否支持特定的格式。
      历史状态管理让我们不必卸载当前页面即可修改浏览器的历史状态栈。有了这种机制，用户就
    可以通过“后退”和“前进”按钮在页面状态间切换，而这些状态完全由 JavaScript 进行控制。

第 17 章 错误处理与调试 

    错误处理对于今天复杂的 Web 应用程序开发而言至关重要。不能提前预测到可能发生的错误，不
    能提前采取恢复策略，可能导致较差的用户体验，最终引发用户不满。多数浏览器在默认情况下都不会
    向用户报告错误，因此在开发和调试期间需要启用浏览器的错误报告功能。然而，在投入运行的产品代
    码中，则不应该再有诸如此类的错误报告出现。
    下面是几种避免浏览器响应 JavaScript 错误的方法。
      在可能发生错误的地方使用 try-catch 语句，这样你还有机会以适当的方式对错误给出响应，
    而不必沿用浏览器处理错误的机制。
      使用 window.onerror 事件处理程序， 这种方式可以接受 try-catch 不能处理的所有错误 （仅
    限于 IE、Firefox 和 Chrome） 。
    另外，对任何 Web 应用程序都应该分析可能的错误来源，并制定处理错误的方案。
      首先，必须要明确什么是致命错误，什么是非致命错误。
      其次，再分析代码，以判断最可能发生的错误。JavaScript 中发生错误的主要原因如下。
      类型转换
      未充分检测数据类型
      发送给服务器或从服务器接收到的数据有错误
    IE、Firefox、Chrome、Opera 和 Safari 都有 JavaScript 调试器，有的是内置的，有的是以需要下载的
    扩展形式存在的。这些调试器都支持设置断点、控制代码执行及在运行时检测变量的值。

第 18 章 JavaScript 与 XML 

    JavaScript 对 XML 及其相关技术有相当大的支持。然而，由于缺乏规范，共同的功能却存在一些不
    同的实现。DOM2 级提供了创建空 XML 文档的 API，但没有涉及解析和序列化。既然规范没有对这些
    功能作出规定，浏览器提供商就各行其是，拿出了自己的实现方案。IE 采取了下列方式。
      通过 ActiveX 对象来支持处理 XML，而相同的对象也可以用来构建桌面应用程序。
      Windows携带了 MSXML 库，JavaScript 能够访问这个库。
      这个库中包含对基本 XML 解析和序列化的支持，同时也支持 XPath 和 XSLT 等技术。
    Firefox 为处理 XML 的解析和序列化，实现了两个新类型，简介如下。
     DOMParser 类型比较简单，其对象可以将 XML 字符串解析为 DOM 文档。
     XMLSerializer 类型执行相反的操作，即将 DOM 文档序列化为 XML 字符串。
    由于 Firefox 中的类型比较简单，用户众多，IE9、Opera、Chrome 和 Safari 都相继实现了相同的类
    型。因此，这些类型也就成为了 Web 开发中的事实标准。
    DOM3 级引入了一个针对 XPath API 的规范，该规范已经由 Firefox、Safari、Chrome 和 Opera 实现。
    这些 API 可以让 JavaScript 基于 DOM 文档运行任何 XPath 查询，并且能够返回任何数据的结果。IE 以
    自己的方式实现了对 XPath 的支持；具体来说，就是两个方法： selectSingleNode() 和
    selectNodes() 。虽然与 DOM3 级 API 相比还存在诸多限制，但使用这两个方法仍然能够执行基本的
    XPath 功能，即在 DOM 文档中查找节点或节点集合。
    与 XML 相关的最后一种技术是 XSLT，没有公开发布的标准针对这种技术的功能定义相应的 API。
    Firefox 为通过 JavaScript 处理转换创建了 XSLTProcessor 类型；此后不久，Safari、Chrome、和 Opera
    也都实现了同样的类型。IE 则针对 XSLT 提供了自己的方案，一个是简单的 transformNode() 方法，
    另一个是较为复杂的模板/处理器手段。
    目前，IE、Firefox、Chrome 和 Opera 都能够较好地支持 XML。虽然 IE 的实现与其他浏览器相比差
    异比较大，但仍然还是有较多的公共功能可供我们实现跨浏览器的方案。

第 19 章 E4X 

    E4X 是以 ECMA-357 标准的形式发布的对 ECMAScript的一个扩展。E4X 的目的是为操作 XML数
    据提供与标准 ECMAScript 更相近的语法。E4X 具有下列特征。
      与 DOM 不同，E4X 只用一个类型来表示 XML 中的各种节点。
     XML 对象中封装了对所有节点都有用的数据和行为。为表现多个节点的集合，这个规范定义了
    XMLList 类型。
      另外两个类型， Namespace 和 QName ，分别表现命名空间和限定名。
    为便于查询 XML 结构，E4X 还修改了标准了的 ECMAScript 语法，修改的地方如下。
      使用两个点（ .. ）表示要匹配所有后代元素，使用 @ 字符表示应该返回一或多个特性。
      星号字符（ * ）是一个通配符，可以匹配任意类型的节点。
      所有这些查询都可以通过一组执行相同操作的方法来实现。
    到2011年底， Firefox还是唯一一个支持E4X的浏览器。 尽管没有其他浏览器提供商承诺会实现E4X，
    但在服务器上，由于 BEA Workshop for WebLogic 和 Yhaoo! YQL 的推动，E4X 已经取得了不小的成功。

第 20 章 JSON 

    JSON 是一个轻量级的数据格式，可以简化表示复杂数据结构的工作量。JSON 使用 JavaScript 语法
    的子集表示对象、数组、字符串、数值、布尔值和 null 。即使 XML 也能表示同样复杂的数据结果，但
    JSON 没有那么烦琐，而且在 JavaScript 中使用更便利。
    ECMAScript 5 定义了一个原生的 JSON 对象，可以用来将对象序列化为 JSON 字符串或者将 JSON
    数据解析为 JavaScript 对象。 JSON.stringify() 和 JSON.parse() 方法分别用来实现上述两项功能。
    这两个方法都有一些选项，通过它们可以改变过滤的方式，或者改变序列化的过程。
    原生的 JSON 对象也得到了很多浏览器的支持，比如 IE8+、Firefox 3.5+、Safari 4+、Opera 10.5 和
    Chrome。

第 21 章 Ajax 与 Comet 

    Ajax 是无需刷新页面就能够从服务器取得数据的一种方法。关于 Ajax，可以从以下几方面来总结
    一下。
      负责 Ajax 运作的核心对象是 XMLHttpRequest （XHR）对象。
      XHR 对象由微软最早在 IE5 中引入，用于通过 JavaScript 从服务器取得 XML 数据。
      在此之后，Firefox、Safari、Chrome 和 Opera 都实现了相同的特性，使 XHR 成为了 Web 的一个
    事实标准。
      虽然实现之间存在差异，但 XHR 对象的基本用法在不同浏览器间还是相对规范的，因此可以放
    心地用在 Web 开发当中。
    同源策略是对 XHR 的一个主要约束，它为通信设置了“相同的域、相同的端口、相同的协议”这一
    限制。试图访问上述限制之外的资源，都会引发安全错误，除非采用被认可的跨域解决方案。这个解决
    方案叫做 CORS（Cross-Origin Resource Sharing，跨源资源共享） ，IE8 通过 XDomainRequest 对象支持
    CORS，其他浏览器通过 XHR 对象原生支持 CORS。图像 Ping 和 JSONP 是另外两种跨域通信的技术，
    但不如 CORS 稳妥。
    Comet 是对 Ajax 的进一步扩展，让服务器几乎能够实时地向客户端推送数据。实现 Comet 的手段
    主要有两个： 长轮询和 HTTP 流。 所有浏览器都支持长轮询， 而只有部分浏览器原生支持 HTTP 流。 SSE
    （Server-Sent Events，服务器发送事件）是一种实现 Comet 交互的浏览器 API，既支持长轮询，也支持
    HTTP 流。
    Web Sockets是一种与服务器进行全双工、双向通信的信道。与其他方案不同，Web Sockets 不使用
    HTTP 协议，而使用一种自定义的协议。这种协议专门为快速传输小数据设计。虽然要求使用不同的
    Web 服务器，但却具有速度上的优势。
    各方面对 Ajax 和 Comet 的鼓吹吸引了越来越多的开发人员学习 JavaScript， 人们对 Web 开发的关注
    也再度升温。与 Ajax 有关的概念都还相对比较新，这些概念会随着时间推移继续发展。

第 22 章 高级技巧 

    JavaScript 中的函数非常强大，因为它们是第一类对象。使用闭包和函数环境切换，还可以有很多
    使用函数的强大方法。 可以创建作用域安全的构造函数， 确保在缺少 new 操作符时调用构造函数不会改
    变错误的环境对象。
      可以使用惰性载入函数，将任何代码分支推迟到第一次调用函数的时候。
      函数绑定可以让你创建始终在指定环境中运行的函数，同时函数柯里化可以让你创建已经填了
    某些参数的函数。
      将绑定和柯里化组合起来，就能够给你一种在任意环境中以任意参数执行任意函数的方法。
    ECMAScript 5允许通过以下几种方式来创建防篡改对象。
      不可扩展的对象，不允许给对象添加新的属性或方法。
      密封的对象，也是不可扩展的对象，不允许删除已有的属性和方法。
      冻结的对象，也是密封的对象，不允许重写对象的成员。
    JavaScript 中可以使用 setTimeout() 和 setInterval() 如下创建定时器。
      定时器代码是放在一个等待区域，直到时间间隔到了之后，此时将代码添加到 JavaScript 的处理
    队列中，等待下一次 JavaScript 进程空闲时被执行。
      每次一段代码执行结束之后，都会有一小段空闲时间进行其他浏览器处理。
      这种行为意味着，可以使用定时器将长时间运行的脚本切分为一小块一小块可以在以后运行的
    代码段。这种做法有助于 Web 应用对用户交互有更积极的响应。
    JavaScript 中经常以事件的形式应用观察者模式。虽然事件常常和 DOM一起使用，但是你也可以通
    过实现自定义事件在自己的代码中应用。使用自定义事件有助于将不同部分的代码相互之间解耦，让维
    护更加容易，并减少引入错误的机会。
    拖放对于桌面和 Web 应用都是一个非常流行的用户界面范例，它能够让用户非常方便地以一种直
    观的方式重新排列或者配置东西。在 JavaScrip 中可以使用鼠标事件和一些简单的计算来实现这种功能
    类型。将拖放行为和自定义事件结合起来可以创建一个可重复使用的框架，它能应用于各种不同的情
    况下。

第 23 章 离线应用与客户端存储 

    离线 Web 应用和客户端存储数据的能力对未来的 Web 应用越来越重要。浏览器已经能够检测到用
    户是否离线，并触发 JavaScript 事件以便应用做出处理。可以指定在应用缓存中保存哪些文件以便离线
    时使用。对于应用缓存的状态及变化，也有相应的 JavaScript API 可以调用检测。
    本书还讨论了客户端存储的以下几方面内容。
      以前，这种存储只能使用 cookie 完成，cookie 是一小块可以客户端设置也可以在服务器端设置
    的信息，每次发起请求时都会传送它。
      在 JavaScript 中通过 document.cookie 可以访问 cookie。
      cookie 的限制使其可以存储少量数据，然而对于大量数据效率很低。
    IE 发明了一种叫做用户数据的行为，可以应用到页面的某个元素上，它有以下特点。
      一旦应用后，该元素便可以从一个命名数据空间中载入数据，然后可以通过 getAttribute() 、
    setAttribute() 和 removeAttribute() 方法访问。
      数据必须明确使用 save() 方法保存到命名数据空间中，以便能在会话之间持久化数据。
    Web Storage 定义了两种用于存储数据的对象： sessionStorage 和 localStorage 。前者严格用
    于在一个浏览器会话中存储数据，因为数据在浏览器关闭后会立即删除；后者用于跨会话持久化数据并
    遵循跨域安全策略。
    IndexedDB是一种类似 SQL 数据库的结构化数据存储机制。但它的数据不是保存在表中，而是保存
    在对象存储空间中。创建对象存储空间时，需要定义一个键，然后就可以添加数据。可以使用游标在对
    象存储空间中查询特定的对象。而索引则是为了提高查询速度而基于特定的属性创建的。
    有了以上这些选择，就可以在客户端机器上使用 JavaScript 存储大量数据了。但你必须小心，不要
    在客户端存储敏感数据，因为数据缓存不会加密

第 24 章 最佳实践 

    随着 JavaScript 开发的成熟，也出现了很多最佳实践。过去一度认为只是一种爱好的东西现在变成
    了正当的职业，同时还需要经历过去其他编程语言要做的一些研究，如可维护性、性能和部署。
    JavaScript 中的可维护性部分涉及到下面的代码约定。
      来自其他语言中的代码约定可以用于决定何时进行注释，以及如何进行缩进，不过 JavaScript
    需要针对其松散类型的性质创造一些特殊的约定。
      由于 JavaScript 必须与 HTML 和 CSS 共存，所以让各自完全定义其自己的目的非常重要：
    JavaScript 应该定义行为，HTML 应该定义内容，CSS 应该定义外观。
      这些职责的混淆会导致难以调试的错误和维护上的问题。
    随着 Web 应用中的 JavaScript 数量的增加，性能变得更加重要，因此，你需要牢记以下事项。
      JavaScript 执行所花费的时间直接影响到整个 Web 页面的性能，所以其重要性是不能忽略的。
      针对基于 C 的语言的很多性能的建议也适用于 JavaScript，如有关循环性能和使用 switch 语句
    替代 if 语句。
      还有一个要记住的重要事情，即 DOM 交互开销很大，所以需要限制 DOM 操作的次数。
    流程的最后一步是部署。本章讨论了以下一些关键点。
      为了协助部署， 推荐设置一个可以将 JavaScript 合并为较少文件 （理想情况是一个） 的构建过程。
      有了构建过程也可以对源代码自动运行额外的处理和过滤。例如，你可以运行 JavaScript 验证器
    来确保没有语法错误或者是代码没有潜在的问题。
      在部署前推荐使用压缩器将文件尽可能变小。
      和 HTTP 压缩一起使用可以让 JavaScript 文件尽可能小，因此对整体页面性能的影响也会最小。

第 25 章 新兴的 API 

    与 HTML5 同时兴起的是另外一批 JavaScript API。从技术规范角度讲，这批 API 不属于 HTML5，
    但从整体上可以称它们为 HTML5 JavaScript API。这些 API 的标准有不少虽然还在制定当中，但已经得
    到了浏览器的广泛支持，因此本章重点讨论了它们。
     requestAnimationFrame() ：是一个着眼于优化 JavaScript 动画的 API，能够在动画运行期间
    发出信号。通过这种机制，浏览器就能够自动优化屏幕重绘操作。
      Page Visibility API：让开发人员知道用户什么时候正在看着页面，而什么时候页面是隐藏的。
      Geolocation API：在得到许可的情况下，可以确定用户所在的位置。在移动 Web 应用中，这个
    API 非常重要而且常用。
      File API：可以读取文件内容，用于显示、处理和上传。与 HTML5 的拖放功能结合，很容易就
    能创造出拖放上传功能。
      Web Timing：给出了页面加载和渲染过程的很多信息，对性能优化非常有价值。
      Web Workers：可以运行异步 JavaScript 代码，避免阻塞用户界面。在执行复杂计算和数据处理
    的时候，这个 API 非常有用；要不然，这些任务轻则会占用很长时间，重则会导致用户无法与
    页面交互。